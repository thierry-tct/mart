{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MART User documentation The details to get started and use Mart are available on the following links: Downloading Mart Building Mart Using Mart Mutants Features and Selection Additional tools Source code documentation You can view the source code doxygen documentation here","title":"Welcome to Mart"},{"location":"#welcome-to-mart","text":"","title":"Welcome to MART"},{"location":"#user-documentation","text":"The details to get started and use Mart are available on the following links: Downloading Mart Building Mart Using Mart Mutants Features and Selection Additional tools","title":"User documentation"},{"location":"#source-code-documentation","text":"You can view the source code doxygen documentation here","title":"Source code documentation"},{"location":"user-doc/building/","text":"Building mart from source Requirements Linux (Tested on Ubuntu) LLVM >= 3.4 (currently tested up to LLVM11) Note: Mart uses JsonBox and dg (for mutant selection's dependence analysis), included as git submodules cmake >= 3.4.3 (for build) bash sudo apt-get install cmake3 gcc >= 4.9.0 or clang ... For older Ubuntu versions, use the following to install vewer gcc: bash sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt-get install gcc-4.9 g++-4.9 which g++ || sudo ln -s /usr/bin/g++-4.9 /usr/bin/g++ fdupes: used by mart to detect equivalent mutants git GNU Make pyhon3 zlib1g-dev and libtinfo-dev: Required on some systems You can used the following command to install dependencies. apt install git cmake make llvm clang g++ python3 fdupes zlib1g-dev libtinfo-dev Note: It is also possible to install LLVM from its source as following. Compile LLVM from source: (example of llvm-3.7.1) svn co http://llvm.org/svn/llvm-project/llvm/tags/RELEASE_371/final llvm-3.7.1/src svn co http://llvm.org/svn/llvm-project/cfe/tags/RELEASE_371/final llvm-3.7.1/src/tools/clang mkdir llvm-3.7.1/build && cd llvm-3.7.1/build && cmake ../src && make -j16 Optional : Install llvm-cbe which works with llvm-3.7 to convert LLVM code to C code git clone https://github.com/JuliaComputing/llvm-cbe.git ../src/projects/llvm-cbe cmake ../src && make -j16 Build docker image Building the image locally git clone --recursive https://github.com/thierry-tct/mart.git mart/src docker build --tag thierrytct/mart mart/src Run Docker container run docker container for demo docker run --rm thierrytct/mart or interactively docker run --rm -it thierrytct/mart /bin/bash Manually build from source Compile MART form source (using cmake version >= 3.4.3): * Clone repository with git clone. ( --recursive to clone the submodules dg and JsonBox) git clone --recursive https://github.com/thierry-tct/mart.git src configure setting LLVM variables: mkdir build && cd build cmake ../src If you have LLVM installed in non-standard paths, or you have several versions of LLVM and want to use a particular one, you must manually specify path to the installation: mkdir build && cd build cmake \\ -DLLVM_SRC_PATH=path_to_llvm_source_root \\ -DLLVM_BUILD_PATH=path_to_llvm_build_root \\ -DLLVM_DIR=path_to_llvm_build_root/share/llvm/cmake \\ path_to_mart_source_root Exemple with the above LLVM-3.7.1 git clone https://github.com/thierry-tct/mart.git mart/src cd mart && mkdir build && cd build cmake \\ -DLLVM_SRC_PATH=/home/mart/llvm-3.7.1/src \\ -DLLVM_BUILD_PATH=/home/mart/llvm-3.7.1/build \\ -DLLVM_DIR=/home/mart/llvm-3.7.1/build/share/llvm/cmake \\ ../src Note : with llvm 6, the LLVM_DIR is set to ... build/lib/cmake/llvm instead of ... build/share/llvm/cmake . make: compile using make while in the build folder. make Testing You can run tests with make tests . The command runs system tests. Build Documentation This requires MKdocs , Doxygen and Graphviz . On Ubuntu, install using the command: sudo apt-get install doxygen graphviz pip install mkdocs mkdocs-include-dir-to-nav Build the documentation using the command (the documentation wil be available in <build-dir>/docs/site ): make gen-docs Push the documentation to the Mart documentation web page using the command: make push-docs","title":"Building mart from source"},{"location":"user-doc/building/#building-mart-from-source","text":"","title":"Building mart from source"},{"location":"user-doc/building/#requirements","text":"Linux (Tested on Ubuntu) LLVM >= 3.4 (currently tested up to LLVM11) Note: Mart uses JsonBox and dg (for mutant selection's dependence analysis), included as git submodules cmake >= 3.4.3 (for build) bash sudo apt-get install cmake3 gcc >= 4.9.0 or clang ... For older Ubuntu versions, use the following to install vewer gcc: bash sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt-get install gcc-4.9 g++-4.9 which g++ || sudo ln -s /usr/bin/g++-4.9 /usr/bin/g++ fdupes: used by mart to detect equivalent mutants git GNU Make pyhon3 zlib1g-dev and libtinfo-dev: Required on some systems You can used the following command to install dependencies. apt install git cmake make llvm clang g++ python3 fdupes zlib1g-dev libtinfo-dev Note: It is also possible to install LLVM from its source as following. Compile LLVM from source: (example of llvm-3.7.1) svn co http://llvm.org/svn/llvm-project/llvm/tags/RELEASE_371/final llvm-3.7.1/src svn co http://llvm.org/svn/llvm-project/cfe/tags/RELEASE_371/final llvm-3.7.1/src/tools/clang mkdir llvm-3.7.1/build && cd llvm-3.7.1/build && cmake ../src && make -j16 Optional : Install llvm-cbe which works with llvm-3.7 to convert LLVM code to C code git clone https://github.com/JuliaComputing/llvm-cbe.git ../src/projects/llvm-cbe cmake ../src && make -j16","title":"Requirements"},{"location":"user-doc/building/#build-docker-image","text":"","title":"Build docker image"},{"location":"user-doc/building/#building-the-image-locally","text":"git clone --recursive https://github.com/thierry-tct/mart.git mart/src docker build --tag thierrytct/mart mart/src","title":"Building the image locally"},{"location":"user-doc/building/#run-docker-container","text":"run docker container for demo docker run --rm thierrytct/mart or interactively docker run --rm -it thierrytct/mart /bin/bash","title":"Run Docker container"},{"location":"user-doc/building/#manually-build-from-source","text":"Compile MART form source (using cmake version >= 3.4.3): * Clone repository with git clone. ( --recursive to clone the submodules dg and JsonBox) git clone --recursive https://github.com/thierry-tct/mart.git src configure setting LLVM variables: mkdir build && cd build cmake ../src If you have LLVM installed in non-standard paths, or you have several versions of LLVM and want to use a particular one, you must manually specify path to the installation: mkdir build && cd build cmake \\ -DLLVM_SRC_PATH=path_to_llvm_source_root \\ -DLLVM_BUILD_PATH=path_to_llvm_build_root \\ -DLLVM_DIR=path_to_llvm_build_root/share/llvm/cmake \\ path_to_mart_source_root Exemple with the above LLVM-3.7.1 git clone https://github.com/thierry-tct/mart.git mart/src cd mart && mkdir build && cd build cmake \\ -DLLVM_SRC_PATH=/home/mart/llvm-3.7.1/src \\ -DLLVM_BUILD_PATH=/home/mart/llvm-3.7.1/build \\ -DLLVM_DIR=/home/mart/llvm-3.7.1/build/share/llvm/cmake \\ ../src Note : with llvm 6, the LLVM_DIR is set to ... build/lib/cmake/llvm instead of ... build/share/llvm/cmake . make: compile using make while in the build folder. make","title":"Manually build from source"},{"location":"user-doc/building/#testing","text":"You can run tests with make tests . The command runs system tests.","title":"Testing"},{"location":"user-doc/building/#build-documentation","text":"This requires MKdocs , Doxygen and Graphviz . On Ubuntu, install using the command: sudo apt-get install doxygen graphviz pip install mkdocs mkdocs-include-dir-to-nav Build the documentation using the command (the documentation wil be available in <build-dir>/docs/site ): make gen-docs Push the documentation to the Mart documentation web page using the command: make push-docs","title":"Build Documentation"},{"location":"user-doc/downloading/","text":"Getting pre-compiled Mart Docker image Use Mart docker image, available on Docker Hub , to run. Get the image Ready Pull the docker image or build the docker image locally 1. Pulling the image docker pull thierrytct/mart Building the image locally git clone --recursive https://github.com/thierry-tct/mart.git mart/src docker build --tag thierrytct/mart mart/src Run Docker container run docker container for demo docker run --rm thierrytct/mart or interactively docker run --rm -it thierrytct/mart /bin/bash","title":"Getting pre-compiled Mart"},{"location":"user-doc/downloading/#getting-pre-compiled-mart","text":"","title":"Getting pre-compiled Mart"},{"location":"user-doc/downloading/#docker-image","text":"Use Mart docker image, available on Docker Hub , to run.","title":"Docker image"},{"location":"user-doc/downloading/#get-the-image-ready","text":"Pull the docker image or build the docker image locally 1. Pulling the image docker pull thierrytct/mart Building the image locally git clone --recursive https://github.com/thierry-tct/mart.git mart/src docker build --tag thierrytct/mart mart/src","title":"Get the image Ready"},{"location":"user-doc/downloading/#run-docker-container","text":"run docker container for demo docker run --rm thierrytct/mart or interactively docker run --rm -it thierrytct/mart /bin/bash","title":"Run Docker container"},{"location":"user-doc/mutants-features-selection/","text":"MART mutants features and selection This feature is enabled when the variable MART_MUTANT_SELECTION is defined during cmake build, as following: -DMART_MUTANT_SELECTION . The Mart's generated mutants' code features can be extracted, after running mart, using the tool mart-selection located in the folder tools . The same tool can be used to predicts the mutans as described on the following paper: [x] Titcheu Chekam, T., Papadakis, M., Bissyand\u00e9, T.F. et al. Selecting fault revealing mutants. Empir Software Eng 25, 434\u2013487 (2020). https://doi.org/10.1007/s10664-019-09778-7 In this same context, the tool mart-training can be used to train the gradient boosted decision tree model described on the paper, which can be used to make the selection. View the help of the tools using: mart-training --help and mart-selection --help","title":"MART mutants features and selection"},{"location":"user-doc/mutants-features-selection/#mart-mutants-features-and-selection","text":"This feature is enabled when the variable MART_MUTANT_SELECTION is defined during cmake build, as following: -DMART_MUTANT_SELECTION . The Mart's generated mutants' code features can be extracted, after running mart, using the tool mart-selection located in the folder tools . The same tool can be used to predicts the mutans as described on the following paper: [x] Titcheu Chekam, T., Papadakis, M., Bissyand\u00e9, T.F. et al. Selecting fault revealing mutants. Empir Software Eng 25, 434\u2013487 (2020). https://doi.org/10.1007/s10664-019-09778-7 In this same context, the tool mart-training can be used to train the gradient boosted decision tree model described on the paper, which can be used to make the selection. View the help of the tools using: mart-training --help and mart-selection --help","title":"MART mutants features and selection"},{"location":"user-doc/mutation_configuration/","text":"Mart Configurtion I. Specifying the mutation scope (source files and functions to mutate) The scope configuration file is a JSON file where the source files and functions to mutate can be specified in two list. The template is the following: { \"Source-Files\": [<function1>, <function2>,...], \"Functions\": [<src_file1>, <src_file2>,...] } Not specifying mutation scope will mean nutating the whole LLVM bitcode module. II. Specifying Mutants operators Teh mutation operators to be applied may be specified using a simple description language. The Specification of the language follows. 1. Syntax Diagram The above Diagram represent the Syntax Diagram of the Mutation operator description language. The Bottom diagram is the representation of both the Matched Fragment and the Compatible Replacement Fragment . Note : The argument ( @, C, V, A, P ) for the Compatible Replacing Fragment must be subset of those specified for the corresponding Matched Fragment . Following is an example of mutation operators configuration: ADD(@1,@2) --> Mutop1.1, SUB(@1, @2); Mutop1.2, SUB(@2, @1); Mutop1.3 TRAPSTMT; LEFTINC(V) --> Mutop2.1, RIGHTDEC(V); Mutop2.2, ASSIGN(V, 0) In this example we have 3 mutation operators: Mutop1.1 : Replace Sum of two expressions by Their Difference. Mutop1.2 : Replace Sum of two expressions by The negation of their difference Difference. Mutop1.3 : Replace Statement having a Sum by a Trap Statement (Failure). Mutop2.1 : Replace Variable left increment by its right decrement. Mutop2.2 : Replace Variable left increment by an assignement of 0 to it. The currently Supported Fragment Elements are listed bellow. 2. Fragment Elements The following table gives information about the currently Supported Fragment Elements (The Fragment Element names are case insensitive). Fragment Element Description Matching Fragment Replacing Fragment Fragment Argument @ Any Scalar Expression \u2713 \u2717 \u2713 C Any Constant \u2713 \u2717 \u2713 V Any Scalar Variable \u2713 \u2717 \u2713 A Any Address \u2713 \u2717 \u2713 P Any Pointer Variable \u2713 \u2717 \u2713 CONSTVAL specific constant value: 1 arg (const val) \u2717 \u2713 \u2717 OPERAND return an operand of an expression: 1 arg (operand class) \u2717 \u2713 \u2717 ABS Absolute value of the argument (single argument) \u2717 \u2713 \u2717 NEG Scalar arithmetic negation \u2713 \u2713 \u2717 ADD Sum of two values \u2713 \u2713 \u2717 SUB Scalar substraction: 2 args (left value, right value) \u2713 \u2713 \u2717 MUL scalar multiplication: 2 args \u2713 \u2713 \u2717 DIV Scalar division: 2 args (numerator, denominator) \u2713 \u2713 \u2717 MOD scalar modulo operation: 2 args (left expr, right expr) \u2713 \u2713 \u2717 BITAND Bit level and :2 args \u2713 \u2713 \u2717 BITNOT bit level not :1 arg \u2713 \u2713 \u2717 BITOR bit level or :2 args \u2713 \u2713 \u2717 BITSHL bit level shift left :2 args (val, shift) \u2713 \u2713 \u2717 BITSHR bit level shift right : 2 args (val, shift) \u2713 \u2713 \u2717 BITXOR bit level xor : 2 args (val, shift) \u2713 \u2713 \u2717 LEFTDEC Scalar left hand decrement: 1 arg (var) \u2713 \u2713 \u2717 LEFTINC Scalar left hand increment: 1 arg (var) \u2713 \u2713 \u2717 RIGHTDEC Scalar variable right decrement: 1 arg (var)) \u2713 \u2713 \u2717 RIGHTINC Scalar variable right decrement: 1 arg (var)) \u2713 \u2713 \u2717 EQ relational equal: 2 args (left expr, right expr) \u2713 \u2713 \u2717 NEQ relational not equal: 2 args (left expr, right expr) \u2713 \u2713 \u2717 GE relational greater or equal: 2 args (left expr, right expr) \u2713 \u2713 \u2717 GT relational greater than: 2 args (left expr, right expr) \u2713 \u2713 \u2717 LE relational less or equal: 2 args (left expr, right expr) \u2713 \u2713 \u2717 LT relational less than: 2 args (left expr, right expr) \u2713 \u2713 \u2717 AND Logical conjunction \u2713 \u2713 \u2717 OR Logical or: 2 args (left expr, right expr)) \u2713 \u2713 \u2717 ASSIGN variable assignement: 2 args (var, expr) \u2713 \u2713 \u2717 PADD Address addition operation with integer: 2 args (address, integer) \u2713 \u2713 \u2717 PSUB Address substraction operation with integer: 2 args (address, integer) \u2713 \u2713 \u2717 PLEFTDEC Pointer variable left decrement: 1 arg (pointer variable) \u2713 \u2713 \u2717 PLEFTINC Pointer variable left increment: 1 arg (pointer variable) \u2713 \u2713 \u2717 PRIGHTDEC Pointer variable right decrement: 1 arg (pointer variable) \u2713 \u2713 \u2717 PRIGHTINC Pointer variable right increment: 1 arg (pointer variable) \u2713 \u2713 \u2717 PEQ Address relational equal operation: 2 args (left addr, right addr) \u2713 \u2713 \u2717 PNEQ Address relational not equal operation \u2713 \u2713 \u2717 PGE Address relational greater or equal operation: 2 args (left addr, right addr) \u2713 \u2713 \u2717 PGT Address relational greater than operation: 2 args (left addr, right addr) \u2713 \u2713 \u2717 PLE Address relational less or equal operation: 2 args (left addr, right addr) \u2713 \u2713 \u2717 PLT Address relational less than operation \u2713 \u2713 \u2717 PADD_DEREF Pointer-int addition followerd by dereference.e.g. *(p+3): 2 args (addess, int) \u2713 \u2713 \u2717 PSUB_DEREF Address-int substraction followed by dereference.e.g. *(p-3): 2 args (Address, int) \u2713 \u2713 \u2717 PDEREF_ADD Pointer dereference followed by addition.e.g. (*p)+2: 2 args (address, number) \u2713 \u2713 \u2717 PDEREF_SUB Pointer dereference followed by substraction.e.g. (*p)-2: 2 args (address, number) \u2713 \u2713 \u2717 PLEFTDEC_DEREF Pointer variable left decrement followed by dereference.e.g. *(--p): 1 args (pointer variable) \u2713 \u2713 \u2717 PLEFTINC_DEREF Pointer variable left increment followed by dereference.e.g. *(--p): 1 args (pointer variable) \u2713 \u2713 \u2717 PRIGHTDEC_DEREF Pointer variable right decrement followed by dereference.e.g. *(p--): 1 args (pointer variable) \u2713 \u2713 \u2717 PRIGHTINC_DEREF Pointer variable right increment followed by dereference.e.g. *(p++): 1 args (pointer variable) \u2713 \u2713 \u2717 PDEREF_LEFTDEC Pointer dereference followed by left decrement.e.g. --(*p): 1 args (pointer variable) \u2713 \u2713 \u2717 PDEREF_LEFTINC Pointer dereference followed by left increment.e.g. ++(*p): 1 args (pointer variable) \u2713 \u2713 \u2717 PDEREF_RIGHTDEC Pointer dereference followed by right decrement.e.g. (*p)--: 1 args (pointer variable) \u2713 \u2713 \u2717 PDEREF_RIGHTINC Pointer dereference followed by right increment.e.g. (*p)++: 1 args (pointer variable) \u2713 \u2713 \u2717 CALL function call: 1 arg (callee) \u2713 \u2717 \u2717 NEWCALLEE Set new callee of function call: 1 arg (new callee) \u2717 \u2713 \u2717 SHUFFLEARGS Shuffle the arguments of a function call: 1 arg (number of args to shuffle) \u2717 \u2713 \u2717 SWITCH Match the a statement: no arg \u2713 \u2717 \u2717 SHUFFLECASESDESTS Shuffle the destination BBs of a switch : 1 arg (number of destination BB to shuffle) \u2717 \u2713 \u2717 REMOVECASES Remove a specific number of cases for switch instruction randomly: 1 args (number of cases to remove) \u2717 \u2713 \u2717 RETURN_BREAK_CONTINUE match return, break or continue: no arg \u2713 \u2717 \u2717 STMT Match any statement \u2713 \u2717 \u2717 DELSTMT remove statement: no args \u2717 \u2713 \u2717 TRAPSTMT a trap statement (artificial failure): no arg \u2717 \u2713 \u2717 3. Programmatically Generate Mutants Operators Configuration In order to programmatically create the mutant operators configuration file, there is a helper python script, located in <path to build dir>/tools/useful/create_mconf.py , that implement a class named GlobalDefs . The objects of the class GlobalDefs have the following iportant properties: 1) FORMATS : Is a key value (python dict) of each relevant Fragment element as key, and the key's value is the fragment element's operands as list of operand classes. 2) RULES : Is a key value (python dict) of each relevant Fragment element as key, and the key's value is the list of compatible fragment element (that can replace this). 3) CLASSES : Define Fragment elements groups. This is a key value (python dict) having as key, each fragment element and as value the corresponding operator groups. Group granularity is represented by different levels separated by the character '/' , similarly to the file system path structure on UNIX systems. e.g. 'EXPRESSION-MUTATION/SCALAR/BINARY/AO' is used for Arithmetic binary operations such as '+', '-', ' ', '/' as these form the same group. Nevertheless, '>', '<' are 'EXPRESSION-MUTATION/SCALAR/BINARY/RO' as they are relational binary operations (Note the common prefix). Thus '+', '-', ' ', '/', '>', '<' belong to the same group 'EXPRESSION-MUTATION/SCALAR/BINARY' for this group granularity.","title":"Mart Configurtion"},{"location":"user-doc/mutation_configuration/#mart-configurtion","text":"","title":"Mart Configurtion"},{"location":"user-doc/mutation_configuration/#i-specifying-the-mutation-scope-source-files-and-functions-to-mutate","text":"The scope configuration file is a JSON file where the source files and functions to mutate can be specified in two list. The template is the following: { \"Source-Files\": [<function1>, <function2>,...], \"Functions\": [<src_file1>, <src_file2>,...] } Not specifying mutation scope will mean nutating the whole LLVM bitcode module.","title":"I. Specifying the mutation scope (source files and functions to mutate)"},{"location":"user-doc/mutation_configuration/#ii-specifying-mutants-operators","text":"Teh mutation operators to be applied may be specified using a simple description language. The Specification of the language follows.","title":"II. Specifying Mutants operators"},{"location":"user-doc/mutation_configuration/#1-syntax-diagram","text":"The above Diagram represent the Syntax Diagram of the Mutation operator description language. The Bottom diagram is the representation of both the Matched Fragment and the Compatible Replacement Fragment . Note : The argument ( @, C, V, A, P ) for the Compatible Replacing Fragment must be subset of those specified for the corresponding Matched Fragment . Following is an example of mutation operators configuration: ADD(@1,@2) --> Mutop1.1, SUB(@1, @2); Mutop1.2, SUB(@2, @1); Mutop1.3 TRAPSTMT; LEFTINC(V) --> Mutop2.1, RIGHTDEC(V); Mutop2.2, ASSIGN(V, 0) In this example we have 3 mutation operators: Mutop1.1 : Replace Sum of two expressions by Their Difference. Mutop1.2 : Replace Sum of two expressions by The negation of their difference Difference. Mutop1.3 : Replace Statement having a Sum by a Trap Statement (Failure). Mutop2.1 : Replace Variable left increment by its right decrement. Mutop2.2 : Replace Variable left increment by an assignement of 0 to it. The currently Supported Fragment Elements are listed bellow.","title":"1. Syntax Diagram"},{"location":"user-doc/mutation_configuration/#2-fragment-elements","text":"The following table gives information about the currently Supported Fragment Elements (The Fragment Element names are case insensitive). Fragment Element Description Matching Fragment Replacing Fragment Fragment Argument @ Any Scalar Expression \u2713 \u2717 \u2713 C Any Constant \u2713 \u2717 \u2713 V Any Scalar Variable \u2713 \u2717 \u2713 A Any Address \u2713 \u2717 \u2713 P Any Pointer Variable \u2713 \u2717 \u2713 CONSTVAL specific constant value: 1 arg (const val) \u2717 \u2713 \u2717 OPERAND return an operand of an expression: 1 arg (operand class) \u2717 \u2713 \u2717 ABS Absolute value of the argument (single argument) \u2717 \u2713 \u2717 NEG Scalar arithmetic negation \u2713 \u2713 \u2717 ADD Sum of two values \u2713 \u2713 \u2717 SUB Scalar substraction: 2 args (left value, right value) \u2713 \u2713 \u2717 MUL scalar multiplication: 2 args \u2713 \u2713 \u2717 DIV Scalar division: 2 args (numerator, denominator) \u2713 \u2713 \u2717 MOD scalar modulo operation: 2 args (left expr, right expr) \u2713 \u2713 \u2717 BITAND Bit level and :2 args \u2713 \u2713 \u2717 BITNOT bit level not :1 arg \u2713 \u2713 \u2717 BITOR bit level or :2 args \u2713 \u2713 \u2717 BITSHL bit level shift left :2 args (val, shift) \u2713 \u2713 \u2717 BITSHR bit level shift right : 2 args (val, shift) \u2713 \u2713 \u2717 BITXOR bit level xor : 2 args (val, shift) \u2713 \u2713 \u2717 LEFTDEC Scalar left hand decrement: 1 arg (var) \u2713 \u2713 \u2717 LEFTINC Scalar left hand increment: 1 arg (var) \u2713 \u2713 \u2717 RIGHTDEC Scalar variable right decrement: 1 arg (var)) \u2713 \u2713 \u2717 RIGHTINC Scalar variable right decrement: 1 arg (var)) \u2713 \u2713 \u2717 EQ relational equal: 2 args (left expr, right expr) \u2713 \u2713 \u2717 NEQ relational not equal: 2 args (left expr, right expr) \u2713 \u2713 \u2717 GE relational greater or equal: 2 args (left expr, right expr) \u2713 \u2713 \u2717 GT relational greater than: 2 args (left expr, right expr) \u2713 \u2713 \u2717 LE relational less or equal: 2 args (left expr, right expr) \u2713 \u2713 \u2717 LT relational less than: 2 args (left expr, right expr) \u2713 \u2713 \u2717 AND Logical conjunction \u2713 \u2713 \u2717 OR Logical or: 2 args (left expr, right expr)) \u2713 \u2713 \u2717 ASSIGN variable assignement: 2 args (var, expr) \u2713 \u2713 \u2717 PADD Address addition operation with integer: 2 args (address, integer) \u2713 \u2713 \u2717 PSUB Address substraction operation with integer: 2 args (address, integer) \u2713 \u2713 \u2717 PLEFTDEC Pointer variable left decrement: 1 arg (pointer variable) \u2713 \u2713 \u2717 PLEFTINC Pointer variable left increment: 1 arg (pointer variable) \u2713 \u2713 \u2717 PRIGHTDEC Pointer variable right decrement: 1 arg (pointer variable) \u2713 \u2713 \u2717 PRIGHTINC Pointer variable right increment: 1 arg (pointer variable) \u2713 \u2713 \u2717 PEQ Address relational equal operation: 2 args (left addr, right addr) \u2713 \u2713 \u2717 PNEQ Address relational not equal operation \u2713 \u2713 \u2717 PGE Address relational greater or equal operation: 2 args (left addr, right addr) \u2713 \u2713 \u2717 PGT Address relational greater than operation: 2 args (left addr, right addr) \u2713 \u2713 \u2717 PLE Address relational less or equal operation: 2 args (left addr, right addr) \u2713 \u2713 \u2717 PLT Address relational less than operation \u2713 \u2713 \u2717 PADD_DEREF Pointer-int addition followerd by dereference.e.g. *(p+3): 2 args (addess, int) \u2713 \u2713 \u2717 PSUB_DEREF Address-int substraction followed by dereference.e.g. *(p-3): 2 args (Address, int) \u2713 \u2713 \u2717 PDEREF_ADD Pointer dereference followed by addition.e.g. (*p)+2: 2 args (address, number) \u2713 \u2713 \u2717 PDEREF_SUB Pointer dereference followed by substraction.e.g. (*p)-2: 2 args (address, number) \u2713 \u2713 \u2717 PLEFTDEC_DEREF Pointer variable left decrement followed by dereference.e.g. *(--p): 1 args (pointer variable) \u2713 \u2713 \u2717 PLEFTINC_DEREF Pointer variable left increment followed by dereference.e.g. *(--p): 1 args (pointer variable) \u2713 \u2713 \u2717 PRIGHTDEC_DEREF Pointer variable right decrement followed by dereference.e.g. *(p--): 1 args (pointer variable) \u2713 \u2713 \u2717 PRIGHTINC_DEREF Pointer variable right increment followed by dereference.e.g. *(p++): 1 args (pointer variable) \u2713 \u2713 \u2717 PDEREF_LEFTDEC Pointer dereference followed by left decrement.e.g. --(*p): 1 args (pointer variable) \u2713 \u2713 \u2717 PDEREF_LEFTINC Pointer dereference followed by left increment.e.g. ++(*p): 1 args (pointer variable) \u2713 \u2713 \u2717 PDEREF_RIGHTDEC Pointer dereference followed by right decrement.e.g. (*p)--: 1 args (pointer variable) \u2713 \u2713 \u2717 PDEREF_RIGHTINC Pointer dereference followed by right increment.e.g. (*p)++: 1 args (pointer variable) \u2713 \u2713 \u2717 CALL function call: 1 arg (callee) \u2713 \u2717 \u2717 NEWCALLEE Set new callee of function call: 1 arg (new callee) \u2717 \u2713 \u2717 SHUFFLEARGS Shuffle the arguments of a function call: 1 arg (number of args to shuffle) \u2717 \u2713 \u2717 SWITCH Match the a statement: no arg \u2713 \u2717 \u2717 SHUFFLECASESDESTS Shuffle the destination BBs of a switch : 1 arg (number of destination BB to shuffle) \u2717 \u2713 \u2717 REMOVECASES Remove a specific number of cases for switch instruction randomly: 1 args (number of cases to remove) \u2717 \u2713 \u2717 RETURN_BREAK_CONTINUE match return, break or continue: no arg \u2713 \u2717 \u2717 STMT Match any statement \u2713 \u2717 \u2717 DELSTMT remove statement: no args \u2717 \u2713 \u2717 TRAPSTMT a trap statement (artificial failure): no arg \u2717 \u2713 \u2717","title":"2. Fragment Elements"},{"location":"user-doc/mutation_configuration/#3-programmatically-generate-mutants-operators-configuration","text":"In order to programmatically create the mutant operators configuration file, there is a helper python script, located in <path to build dir>/tools/useful/create_mconf.py , that implement a class named GlobalDefs . The objects of the class GlobalDefs have the following iportant properties: 1) FORMATS : Is a key value (python dict) of each relevant Fragment element as key, and the key's value is the fragment element's operands as list of operand classes. 2) RULES : Is a key value (python dict) of each relevant Fragment element as key, and the key's value is the list of compatible fragment element (that can replace this). 3) CLASSES : Define Fragment elements groups. This is a key value (python dict) having as key, each fragment element and as value the corresponding operator groups. Group granularity is represented by different levels separated by the character '/' , similarly to the file system path structure on UNIX systems. e.g. 'EXPRESSION-MUTATION/SCALAR/BINARY/AO' is used for Arithmetic binary operations such as '+', '-', ' ', '/' as these form the same group. Nevertheless, '>', '<' are 'EXPRESSION-MUTATION/SCALAR/BINARY/RO' as they are relational binary operations (Note the common prefix). Thus '+', '-', ' ', '/', '>', '<' belong to the same group 'EXPRESSION-MUTATION/SCALAR/BINARY' for this group granularity.","title":"3. Programmatically Generate Mutants Operators Configuration"},{"location":"user-doc/othertools/","text":"Mutant generation utilities There is a utility called mart-utils that can be used to post precess the output of Mart. This can be used to generate individual mutants bitcode when Mart was run to only generate Meta-mutant bitcode file. For the usage, check the script mutants_bc_from_meta .","title":"Mutant generation utilities"},{"location":"user-doc/othertools/#mutant-generation-utilities","text":"There is a utility called mart-utils that can be used to post precess the output of Mart. This can be used to generate individual mutants bitcode when Mart was run to only generate Meta-mutant bitcode file. For the usage, check the script mutants_bc_from_meta .","title":"Mutant generation utilities"},{"location":"user-doc/using/","text":"Using MART mutant generation Test Automation For use in the integration with other testing tools such ast automated test generation tools, Muteria is a good way to use Mart (Check out the example_c usage from Muteria ). For direct usage of Mart , checkout the usage demo video here . Compile your code into LLVM bitcode (.bc) file Use clang to build the C language program ( .c) into LLVM bitcode ( .c) with a command of the form: clang -c -emit-llvm -g <SourceFile>.c -o <BitFile>.bc You may use wllvm for large C/C++ projects. Compile with debug flag enable ( -g option for C/C++ compilers gcc and clang) and without optimization to have mutants closer to source code mutants. Generate the mutants Use Mart through command line. The usage format is the following: <path to mart build dir>/tools/mart [OPTIONS] <bitcode file to mutate> View the help on usage with the command: <path to mart build dir>/tools/mart --help Mutation Generation Configuration Mutant generation configuration consist in 2 configurations: Code locations to mutates (mutation scope): This specifies the source files and functions to mutate. This is done using the option: -mutant-scope <path/to/mutant scope file> Mutation operators to apply: This specifies the mutation operator to apply. Mart's way of specifying mutants is flexible. For example, the user has control on the constant to replace when replacing an expression with a constant value. This is done using the option: -mutant-config <path./to/mutant config file> . Note : If mutants operators configuration is not specified, the default configuration of 816 transformation rule is used. That default configuration file is located in <path to build dir>/tools/useful/mconf-scope/default_allmax.mconf Find the details about the format and language to specify the configuration here .","title":"Using MART mutant generation"},{"location":"user-doc/using/#using-mart-mutant-generation","text":"","title":"Using MART mutant generation"},{"location":"user-doc/using/#test-automation","text":"For use in the integration with other testing tools such ast automated test generation tools, Muteria is a good way to use Mart (Check out the example_c usage from Muteria ). For direct usage of Mart , checkout the usage demo video here .","title":"Test Automation"},{"location":"user-doc/using/#compile-your-code-into-llvm-bitcode-bc-file","text":"Use clang to build the C language program ( .c) into LLVM bitcode ( .c) with a command of the form: clang -c -emit-llvm -g <SourceFile>.c -o <BitFile>.bc You may use wllvm for large C/C++ projects. Compile with debug flag enable ( -g option for C/C++ compilers gcc and clang) and without optimization to have mutants closer to source code mutants.","title":"Compile your code into LLVM bitcode (.bc) file"},{"location":"user-doc/using/#generate-the-mutants","text":"Use Mart through command line. The usage format is the following: <path to mart build dir>/tools/mart [OPTIONS] <bitcode file to mutate> View the help on usage with the command: <path to mart build dir>/tools/mart --help","title":"Generate the mutants"},{"location":"user-doc/using/#mutation-generation-configuration","text":"Mutant generation configuration consist in 2 configurations: Code locations to mutates (mutation scope): This specifies the source files and functions to mutate. This is done using the option: -mutant-scope <path/to/mutant scope file> Mutation operators to apply: This specifies the mutation operator to apply. Mart's way of specifying mutants is flexible. For example, the user has control on the constant to replace when replacing an expression with a constant value. This is done using the option: -mutant-config <path./to/mutant config file> . Note : If mutants operators configuration is not specified, the default configuration of 816 transformation rule is used. That default configuration file is located in <path to build dir>/tools/useful/mconf-scope/default_allmax.mconf Find the details about the format and language to specify the configuration here .","title":"Mutation Generation Configuration"}]}