<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MART: A Mutant Generation Tool for LLVM: mart::FunctionCall Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MART: A Mutant Generation Tool for LLVM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemart.html">mart</a></li><li class="navelem"><a class="el" href="classmart_1_1FunctionCall.html">FunctionCall</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classmart_1_1FunctionCall-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mart::FunctionCall Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mart::FunctionCall:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1FunctionCall__inherit__graph.png" border="0" usemap="#mart_1_1FunctionCall_inherit__map" alt="Inheritance graph"/></div>
<map name="mart_1_1FunctionCall_inherit__map" id="mart_1_1FunctionCall_inherit__map">
<area shape="rect" title=" " alt="" coords="25,155,167,181"/>
<area shape="rect" href="classmart_1_1MatchOnly__Base.html" title=" " alt="" coords="11,80,181,107"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html" title=" " alt="" coords="5,5,187,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mart::FunctionCall:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1FunctionCall__coll__graph.png" border="0" usemap="#mart_1_1FunctionCall_coll__map" alt="Collaboration graph"/></div>
<map name="mart_1_1FunctionCall_coll__map" id="mart_1_1FunctionCall_coll__map">
<area shape="rect" title=" " alt="" coords="25,155,167,181"/>
<area shape="rect" href="classmart_1_1MatchOnly__Base.html" title=" " alt="" coords="11,80,181,107"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html" title=" " alt="" coords="5,5,187,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae82180586186545d25fa2578a543b6d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1FunctionCall.html#ae82180586186545d25fa2578a543b6d5">matchIRs</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> const &amp;mutationOp, unsigned pos, <a class="el" href="structmart_1_1MatchUseful.html">MatchUseful</a> &amp;MU, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:ae82180586186545d25fa2578a543b6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match the IR pattern that can be mutated by this operator, starting from the IR at position 'pos'. For those that create only, report an error.  <a href="classmart_1_1FunctionCall.html#ae82180586186545d25fa2578a543b6d5">More...</a><br /></td></tr>
<tr class="separator:ae82180586186545d25fa2578a543b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cf5a1415214cce26f53c8d1e521b7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1FunctionCall.html#ac1cf5a1415214cce26f53c8d1e521b7f">prepareCloneIRs</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, unsigned pos, <a class="el" href="structmart_1_1MatchUseful.html">MatchUseful</a> const &amp;MU, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1DoReplaceUseful.html">DoReplaceUseful</a> &amp;DRU, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:ac1cf5a1415214cce26f53c8d1e521b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">make the clones that will be mutated  <a href="classmart_1_1FunctionCall.html#ac1cf5a1415214cce26f53c8d1e521b7f">More...</a><br /></td></tr>
<tr class="separator:ac1cf5a1415214cce26f53c8d1e521b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f11c184b01072f5061a10ea3e47ebdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1FunctionCall.html#a8f11c184b01072f5061a10ea3e47ebdd">matchAndReplace</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> const &amp;mutationOp, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;iswholestmtmutated, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:a8f11c184b01072f5061a10ea3e47ebdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match the IR pattern and mutate. This is entry-point method called during mutation. Reimplement this as needed. \detail The method take a statement, a code pattern type to match (Ex: Add 2 integers) as well as the muatant code pattern and generatemutated clones of the statement.  <a href="classmart_1_1FunctionCall.html#a8f11c184b01072f5061a10ea3e47ebdd">More...</a><br /></td></tr>
<tr class="separator:a8f11c184b01072f5061a10ea3e47ebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmart_1_1GenericMuOpBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmart_1_1GenericMuOpBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmart_1_1GenericMuOpBase.html">mart::GenericMuOpBase</a></td></tr>
<tr class="memitem:ae3fdf68be2f9bf6770e0b1547b16e74e inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#ae3fdf68be2f9bf6770e0b1547b16e74e">~GenericMuOpBase</a> ()</td></tr>
<tr class="separator:ae3fdf68be2f9bf6770e0b1547b16e74e inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95545ab2f94944d4f0da0c8c26faa53f inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a95545ab2f94944d4f0da0c8c26faa53f">getMinIRInstructionsToBeMatched</a> ()</td></tr>
<tr class="memdesc:a95545ab2f94944d4f0da0c8c26faa53f inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thismethod is useful to help filter before hand the operation that can never be matched in a stmt. overload this in the operator classes.  <a href="classmart_1_1GenericMuOpBase.html#a95545ab2f94944d4f0da0c8c26faa53f">More...</a><br /></td></tr>
<tr class="separator:a95545ab2f94944d4f0da0c8c26faa53f inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7227537ba250ce935c7eecf6e5abf805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1FunctionCall.html#a7227537ba250ce935c7eecf6e5abf805">permute</a> (std::vector&lt; unsigned &gt; const &amp;invect, std::vector&lt; std::vector&lt; unsigned &gt;&gt; &amp;permutations)</td></tr>
<tr class="separator:a7227537ba250ce935c7eecf6e5abf805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be7a8b80187e6cd20a704352441bf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1FunctionCall.html#a9be7a8b80187e6cd20a704352441bf0e">getCombinations</a> (std::vector&lt; unsigned &gt; const &amp;invector, unsigned select_size, unsigned startpos, std::vector&lt; unsigned &gt; workVector, std::vector&lt; std::vector&lt; unsigned &gt;&gt; &amp;combinations)</td></tr>
<tr class="separator:a9be7a8b80187e6cd20a704352441bf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada24fe68f6dad0638bf5645d0b6d8055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1FunctionCall.html#ada24fe68f6dad0638bf5645d0b6d8055">generateCombinations</a> (llvm::CallInst *call, unsigned shuffle_size, std::vector&lt; std::vector&lt; unsigned &gt;&gt; &amp;results)</td></tr>
<tr class="separator:ada24fe68f6dad0638bf5645d0b6d8055"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classmart_1_1GenericMuOpBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmart_1_1GenericMuOpBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmart_1_1GenericMuOpBase.html">mart::GenericMuOpBase</a></td></tr>
<tr class="memitem:aca35f9420c452f9c5e51821d52097f1e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#aca35f9420c452f9c5e51821d52097f1e">isSequentialType</a> (const llvm::Type *type)</td></tr>
<tr class="memdesc:aca35f9420c452f9c5e51821d52097f1e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tels whether the llvm type is a sequential type.  <a href="classmart_1_1GenericMuOpBase.html#aca35f9420c452f9c5e51821d52097f1e">More...</a><br /></td></tr>
<tr class="separator:aca35f9420c452f9c5e51821d52097f1e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eba5272a8370c83f75bf4a603d38b83 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a8eba5272a8370c83f75bf4a603d38b83">isCompositeType</a> (const llvm::Type *type)</td></tr>
<tr class="memdesc:a8eba5272a8370c83f75bf4a603d38b83 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tels whether the llvm type is a composite type.  <a href="classmart_1_1GenericMuOpBase.html#a8eba5272a8370c83f75bf4a603d38b83">More...</a><br /></td></tr>
<tr class="separator:a8eba5272a8370c83f75bf4a603d38b83 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5291dbb8115dd6bd6efc55e3b86b11a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#ac5291dbb8115dd6bd6efc55e3b86b11a">checkCPTypeInIR</a> (enum <a class="el" href="namespacemart.html#aff3b79ebfdbde74c201459822668f148">codeParts</a> cpt, llvm::Value *val)</td></tr>
<tr class="memdesc:ac5291dbb8115dd6bd6efc55e3b86b11a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">the method checkCPTypeInIR - "Check Code Part Type In IR" - validate the seen value type match with the expected one. \detail Use this when matching IR with code parts to mutate, to match each oprd in IR with expected CPType  <a href="classmart_1_1GenericMuOpBase.html#ac5291dbb8115dd6bd6efc55e3b86b11a">More...</a><br /></td></tr>
<tr class="separator:ac5291dbb8115dd6bd6efc55e3b86b11a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe944b290c20a4bbdd13255f59dbcc8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a0fe944b290c20a4bbdd13255f59dbcc8">createIfConst</a> (llvm::Type *type, unsigned posConstValueMap_POS)</td></tr>
<tr class="memdesc:a0fe944b290c20a4bbdd13255f59dbcc8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method obtain a constant numeric from a string contained in a static structure of.  <a href="classmart_1_1GenericMuOpBase.html#a0fe944b290c20a4bbdd13255f59dbcc8">More...</a><br /></td></tr>
<tr class="separator:a0fe944b290c20a4bbdd13255f59dbcc8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8294e52f9debc2dfddc4038145250f71 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a8294e52f9debc2dfddc4038145250f71">reverseCast</a> (llvm::Instruction::CastOps toRev, llvm::Value *subj, llvm::Type *destTy)</td></tr>
<tr class="memdesc:a8294e52f9debc2dfddc4038145250f71 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method applies the reverse of a "cast" instruction. Ex: passing IntToPtr will return PtrToInt.  <a href="classmart_1_1GenericMuOpBase.html#a8294e52f9debc2dfddc4038145250f71">More...</a><br /></td></tr>
<tr class="separator:a8294e52f9debc2dfddc4038145250f71 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae833ae34954dc85511ccd6acd9a65c4e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#ae833ae34954dc85511ccd6acd9a65c4e">getTerminatorDeleterCode</a> ()</td></tr>
<tr class="memdesc:ae833ae34954dc85511ccd6acd9a65c4e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the matcher/replacor code for the operation that can delete statement which are block terminators (like return, break, continue)  <a href="classmart_1_1GenericMuOpBase.html#ae833ae34954dc85511ccd6acd9a65c4e">More...</a><br /></td></tr>
<tr class="separator:ae833ae34954dc85511ccd6acd9a65c4e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bea55a64c6aa3bea0f26ab0bb0f32c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a21bea55a64c6aa3bea0f26ab0bb0f32c">getGenericDeleterCode</a> ()</td></tr>
<tr class="memdesc:a21bea55a64c6aa3bea0f26ab0bb0f32c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the matcher/replacor code for the operation that can delete any statement (like return, break, continue)  <a href="classmart_1_1GenericMuOpBase.html#a21bea55a64c6aa3bea0f26ab0bb0f32c">More...</a><br /></td></tr>
<tr class="separator:a21bea55a64c6aa3bea0f26ab0bb0f32c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689ca298ae6ee072ee17af66a4ba295d inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a689ca298ae6ee072ee17af66a4ba295d">getGenericTrapInserterCode</a> ()</td></tr>
<tr class="memdesc:a689ca298ae6ee072ee17af66a4ba295d inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the matcher/replacor code for the operation that can delete any statement (like return, break, continue)  <a href="classmart_1_1GenericMuOpBase.html#a689ca298ae6ee072ee17af66a4ba295d">More...</a><br /></td></tr>
<tr class="separator:a689ca298ae6ee072ee17af66a4ba295d inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd889ccd23a76605410fcab652a6fc9 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#affd889ccd23a76605410fcab652a6fc9">isDeletion</a> (enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a> m)</td></tr>
<tr class="memdesc:affd889ccd23a76605410fcab652a6fc9 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an operation is Del stmt, which deletes the whole statement, or for return statement, set returned value to 0.  <a href="classmart_1_1GenericMuOpBase.html#affd889ccd23a76605410fcab652a6fc9">More...</a><br /></td></tr>
<tr class="separator:affd889ccd23a76605410fcab652a6fc9 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c9cb3f51681b060417d0819e881d7c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#aa0c9cb3f51681b060417d0819e881d7c">isTrapInsertion</a> (enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a> m)</td></tr>
<tr class="memdesc:aa0c9cb3f51681b060417d0819e881d7c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an operation is Trap stmt, which replace the whole statement by trap(basically inserting trap before) This make the program abort when the stmt is reached.  <a href="classmart_1_1GenericMuOpBase.html#aa0c9cb3f51681b060417d0819e881d7c">More...</a><br /></td></tr>
<tr class="separator:aa0c9cb3f51681b060417d0819e881d7c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc34edc65cee39c46f286f994d2326d1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#afc34edc65cee39c46f286f994d2326d1">doDeleteStmt</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;iswholestmtmutated, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:afc34edc65cee39c46f286f994d2326d1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the mutant of delete stmt, for the case where the statement is not a terminator (break, continue, return). For that,.  <a href="classmart_1_1GenericMuOpBase.html#afc34edc65cee39c46f286f994d2326d1">More...</a><br /></td></tr>
<tr class="separator:afc34edc65cee39c46f286f994d2326d1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f28b422ddada01b8a9c2deaa7982e1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#ae5f28b422ddada01b8a9c2deaa7982e1">doTrapStmt</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;iswholestmtmutated, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:ae5f28b422ddada01b8a9c2deaa7982e1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the mutant of trap stmt, for the case where the statement.  <a href="classmart_1_1GenericMuOpBase.html#ae5f28b422ddada01b8a9c2deaa7982e1">More...</a><br /></td></tr>
<tr class="separator:ae5f28b422ddada01b8a9c2deaa7982e1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af011cf018d29f485e1d4af0b60e9edf8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#af011cf018d29f485e1d4af0b60e9edf8">checkWholeStmtAndMutate</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;iswholestmtmutated, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:af011cf018d29f485e1d4af0b60e9edf8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the replacer is wholestmt mutation and return true or false. if it is, create the corresponding mutation  <a href="classmart_1_1GenericMuOpBase.html#af011cf018d29f485e1d4af0b60e9edf8">More...</a><br /></td></tr>
<tr class="separator:af011cf018d29f485e1d4af0b60e9edf8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5999df8142a41800b6f240f4e0e3822a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a5999df8142a41800b6f240f4e0e3822a">constAndEquals</a> (llvm::Value *c1, llvm::Value *c2)</td></tr>
<tr class="memdesc:a5999df8142a41800b6f240f4e0e3822a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two values of the same type are constant and of same values.  <a href="classmart_1_1GenericMuOpBase.html#a5999df8142a41800b6f240f4e0e3822a">More...</a><br /></td></tr>
<tr class="separator:a5999df8142a41800b6f240f4e0e3822a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb27fe2351ba131fdb30509b00f3556a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#afb27fe2351ba131fdb30509b00f3556a">checkIsPointerIndexingAndGet</a> (llvm::GetElementPtrInst const *gep, int &amp;index)</td></tr>
<tr class="separator:afb27fe2351ba131fdb30509b00f3556a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d8870056fff4d2649b6149ac0837ce inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a52d8870056fff4d2649b6149ac0837ce">doReplacement</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1MutantsOfStmt_1_1MutantStmtIR.html">MutantsOfStmt::MutantStmtIR</a> &amp;toMatchMutant, std::vector&lt; unsigned &gt; &amp;posOfIRtoRemove, llvm::Value *oprd1_addrOprd, llvm::Value *oprd2_intValOprd, int returningIRPos, std::vector&lt; unsigned &gt; const &amp;relevantPosInToMatch, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI, int returnIntoIRPos=-1, int retIntoOprdIndex=-1)</td></tr>
<tr class="memdesc:a52d8870056fff4d2649b6149ac0837ce inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutate the statement (list if LLVM IR Instructions) 'toMatchMutant' a clone of the original statement 'toMatch' then append the mutated statement (from 'toMatchMutant') into 'resultMuts' \detail There are two modes: (1) specifying the IR whose value is replaced by the created operation's value (here all its uses become the uses of the created operation). Such IR is specified with the parameter 'returningIR'. in this case, 'returnIntoIR' must be null and retIntoOprdIndex &lt; 0. (2) Specifying the single IR where the value of the created operation is used ('returnIntoIR'). Here the corresponding operand index is also specified ('retIntoOprdIndex'). Note that 'returningIR' must be null in this case.  <a href="classmart_1_1GenericMuOpBase.html#a52d8870056fff4d2649b6149ac0837ce">More...</a><br /></td></tr>
<tr class="separator:a52d8870056fff4d2649b6149ac0837ce inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ada24fe68f6dad0638bf5645d0b6d8055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada24fe68f6dad0638bf5645d0b6d8055">&#9670;&nbsp;</a></span>generateCombinations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mart::FunctionCall::generateCombinations </td>
          <td>(</td>
          <td class="paramtype">llvm::CallInst *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>shuffle_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1FunctionCall_ada24fe68f6dad0638bf5645d0b6d8055_cgraph.png" border="0" usemap="#classmart_1_1FunctionCall_ada24fe68f6dad0638bf5645d0b6d8055_cgraph" alt=""/></div>
<map name="classmart_1_1FunctionCall_ada24fe68f6dad0638bf5645d0b6d8055_cgraph" id="classmart_1_1FunctionCall_ada24fe68f6dad0638bf5645d0b6d8055_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,184,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a9be7a8b80187e6cd20a704352441bf0e" title=" " alt="" coords="232,5,373,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a7227537ba250ce935c7eecf6e5abf805" title=" " alt="" coords="421,5,563,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1FunctionCall_ada24fe68f6dad0638bf5645d0b6d8055_icgraph.png" border="0" usemap="#classmart_1_1FunctionCall_ada24fe68f6dad0638bf5645d0b6d8055_icgraph" alt=""/></div>
<map name="classmart_1_1FunctionCall_ada24fe68f6dad0638bf5645d0b6d8055_icgraph" id="classmart_1_1FunctionCall_ada24fe68f6dad0638bf5645d0b6d8055_icgraph">
<area shape="rect" title=" " alt="" coords="201,5,380,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a8f11c184b01072f5061a10ea3e47ebdd" title="Match the IR pattern and mutate. This is entry&#45;point method called during mutation...." alt="" coords="5,5,153,47"/>
</map>
</div>

</div>
</div>
<a id="a9be7a8b80187e6cd20a704352441bf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be7a8b80187e6cd20a704352441bf0e">&#9670;&nbsp;</a></span>getCombinations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mart::FunctionCall::getCombinations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned &gt; const &amp;&#160;</td>
          <td class="paramname"><em>invector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>select_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>startpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>workVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>combinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1FunctionCall_a9be7a8b80187e6cd20a704352441bf0e_cgraph.png" border="0" usemap="#classmart_1_1FunctionCall_a9be7a8b80187e6cd20a704352441bf0e_cgraph" alt=""/></div>
<map name="classmart_1_1FunctionCall_a9be7a8b80187e6cd20a704352441bf0e_cgraph" id="classmart_1_1FunctionCall_a9be7a8b80187e6cd20a704352441bf0e_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,147,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a7227537ba250ce935c7eecf6e5abf805" title=" " alt="" coords="195,5,336,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1FunctionCall_a9be7a8b80187e6cd20a704352441bf0e_icgraph.png" border="0" usemap="#classmart_1_1FunctionCall_a9be7a8b80187e6cd20a704352441bf0e_icgraph" alt=""/></div>
<map name="classmart_1_1FunctionCall_a9be7a8b80187e6cd20a704352441bf0e_icgraph" id="classmart_1_1FunctionCall_a9be7a8b80187e6cd20a704352441bf0e_icgraph">
<area shape="rect" title=" " alt="" coords="428,5,569,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#ada24fe68f6dad0638bf5645d0b6d8055" title=" " alt="" coords="201,5,380,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a8f11c184b01072f5061a10ea3e47ebdd" title="Match the IR pattern and mutate. This is entry&#45;point method called during mutation...." alt="" coords="5,5,153,47"/>
</map>
</div>

</div>
</div>
<a id="a8f11c184b01072f5061a10ea3e47ebdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f11c184b01072f5061a10ea3e47ebdd">&#9670;&nbsp;</a></span>matchAndReplace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mart::FunctionCall::matchAndReplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;&#160;</td>
          <td class="paramname"><em>toMatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> const &amp;&#160;</td>
          <td class="paramname"><em>mutationOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;&#160;</td>
          <td class="paramname"><em>resultMuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;&#160;</td>
          <td class="paramname"><em>iswholestmtmutated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;&#160;</td>
          <td class="paramname"><em>MI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match the IR pattern and mutate. This is entry-point method called during mutation. Reimplement this as needed. \detail The method take a statement, a code pattern type to match (Ex: Add 2 integers) as well as the muatant code pattern and generatemutated clones of the statement. </p>
<p>A virtual member. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toMatch</td><td>is the statement in which we want to match the candidate pattern to muatate. </td></tr>
    <tr><td class="paramname">mutationOp</td><td>contains the pattern to match as well as the replacing ones. </td></tr>
    <tr><td class="paramname">resultMuts</td><td>is the list where the generated mutants of the initial statement should be appended. </td></tr>
    <tr><td class="paramname">iswholestmtmutated</td><td>is the flag that help to know wheter the statement has already been mutated (for whole stmt mutation,) by previous mutation op. Changed from false to true after deletion occurs. </td></tr>
    <tr><td class="paramname">MI</td><td>is the parameter containing the global information. </td></tr>
  </table>
  </dd>
</dl>
<p>MATCH</p>

<p>Reimplemented from <a class="el" href="classmart_1_1GenericMuOpBase.html#a97a5f21c843085d4be1e0180dec105e8">mart::GenericMuOpBase</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1FunctionCall_a8f11c184b01072f5061a10ea3e47ebdd_cgraph.png" border="0" usemap="#classmart_1_1FunctionCall_a8f11c184b01072f5061a10ea3e47ebdd_cgraph" alt=""/></div>
<map name="classmart_1_1FunctionCall_a8f11c184b01072f5061a10ea3e47ebdd_cgraph" id="classmart_1_1FunctionCall_a8f11c184b01072f5061a10ea3e47ebdd_cgraph">
<area shape="rect" title="Match the IR pattern and mutate. This is entry&#45;point method called during mutation...." alt="" coords="5,2182,153,2223"/>
<area shape="rect" href="structmart_1_1MutantsOfStmt.html#a9f2660bd2cd0588c7043b12486d57f18" title="This method add a new mutant statement. \detail It computes the corresponding Weak mutation using dif..." alt="" coords="1308,489,1500,516"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#af011cf018d29f485e1d4af0b60e9edf8" title="check whether the replacer is wholestmt mutation and return true or false. if it is,..." alt="" coords="201,887,412,929"/>
<area shape="rect" href="structmart_1_1MutantsOfStmt_1_1MutantStmtIR.html#a6880272c11fe8dc99ffa87d6786b2411" title=" " alt="" coords="1324,2005,1484,2046"/>
<area shape="rect" href="structmart_1_1MutantsOfStmt_1_1MutantStmtIR.html#a1397eb93298fd0ea7024467654a7bacc" title=" " alt="" coords="1316,2270,1492,2311"/>
<area shape="rect" href="structmart_1_1MatchStmtIR.html#abbbcceb3506b42482dc38b0780b2a654" title=" " alt="" coords="1033,2070,1186,2111"/>
<area shape="rect" href="classmart_1_1llvmMutationOp.html#ae0984e929c3c8fd6471de1505a385aaa" title=" " alt="" coords="1017,2135,1201,2177"/>
<area shape="rect" href="structmart_1_1ModuleUserInfos.html#aee91e12da903d1f6d13828c72d36ef17" title=" " alt="" coords="729,109,900,150"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#ada24fe68f6dad0638bf5645d0b6d8055" title=" " alt="" coords="217,2291,396,2333"/>
<area shape="rect" href="classmart_1_1llvmMutationOp.html#a8afc97df809f870fa0e013685a919bd8" title=" " alt="" coords="223,2357,390,2398"/>
<area shape="rect" href="classmart_1_1llvmMutationOp.html#af6f3cb956dbca307c3c2457044bf378b" title=" " alt="" coords="220,2422,393,2463"/>
<area shape="rect" href="structmart_1_1MutantsOfStmt_1_1MutantStmtIR.html#afd9e7a80ccb4c3a5fad83cf82d1ad998" title="Clone a statement into a new one. The structural relation betwenn IRs in original is kept \detail Ass..." alt="" coords="207,617,406,673"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#afc34edc65cee39c46f286f994d2326d1" title="Create the mutant of delete stmt, for the case where the statement is not a terminator (break,..." alt="" coords="460,887,641,929"/>
<area shape="rect" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html#acb021cbe109e459c8d0831b16204a33c" title=" " alt="" coords="1279,1913,1529,1954"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#ae5f28b422ddada01b8a9c2deaa7982e1" title="Create the mutant of trap stmt, for the case where the statement." alt="" coords="460,350,641,391"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#affd889ccd23a76605410fcab652a6fc9" title="Check whether an operation is Del stmt, which deletes the whole statement, or for return statement,..." alt="" coords="460,731,641,773"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#aa0c9cb3f51681b060417d0819e881d7c" title="Check whether an operation is Trap stmt, which replace the whole statement by trap(basically insertin..." alt="" coords="460,226,641,267"/>
<area shape="rect" href="classmart_1_1llvmMutationOp.html#a52fd8ee7e8d6b3edb8f19d08381f83d5" title=" " alt="" coords="731,855,898,897"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#a21bea55a64c6aa3bea0f26ab0bb0f32c" title="get the matcher/replacor code for the operation that can delete any statement (like return,..." alt="" coords="723,673,906,714"/>
<area shape="rect" href="classmart_1_1UserMaps.html#ad9347edff14677018d4383b95de40c1f" title=" " alt="" coords="1300,1459,1508,1501"/>
<area shape="rect" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html#a8631afbfbca6808e17074058c8073af5" title=" " alt="" coords="689,921,940,962"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#ae833ae34954dc85511ccd6acd9a65c4e" title="get the matcher/replacor code for the operation that can delete statement which are block terminators..." alt="" coords="713,986,916,1027"/>
<area shape="rect" href="structmart_1_1MatchStmtIR.html#ad0b73a8e1a4e3397fde4eb181c3fc08d" title=" " alt="" coords="738,526,891,567"/>
<area shape="rect" href="structmart_1_1ModuleUserInfos.html#a23b1e979cc8b3d0811c15c6c4bcf1ad0" title=" " alt="" coords="1319,1686,1489,1727"/>
<area shape="rect" href="structmart_1_1WholeStmtMutationOnce.html#a612bf422648137dabfe14009c281dbc7" title=" " alt="" coords="703,1117,927,1158"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#a97a5f21c843085d4be1e0180dec105e8" title="Match the IR pattern and mutate. This is entry&#45;point method called during mutation...." alt="" coords="724,1639,905,1681"/>
<area shape="rect" href="structmart_1_1WholeStmtMutationOnce.html#ae69ac4fdcfe30125e4e8fd13779d9b67" title=" " alt="" coords="703,738,927,779"/>
<area shape="rect" href="classmart_1_1llvmMutationOp.html#a8ba20cd49bcb17c0134befb8b70dfe39" title=" " alt="" coords="731,1051,898,1093"/>
<area shape="rect" href="structmart_1_1MutantsOfStmt_1_1MutantStmtIR.html#a624dece777cab8cc44400cc3e986d779" title=" " alt="" coords="713,592,917,648"/>
<area shape="rect" href="structmart_1_1MatchStmtIR.html#a199dd9e86482b2a3baa8b83eafa68ab8" title=" " alt="" coords="717,409,912,450"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#aabcbf1e1bdd8098c0cf36c9977cd318c" title=" " alt="" coords="1034,1822,1185,1863"/>
<area shape="rect" href="structmart_1_1DoReplaceUseful.html#ae06de8beaa44b23871b9fbc978e1d2b5" title=" " alt="" coords="1023,2005,1196,2046"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#a52d8870056fff4d2649b6149ac0837ce" title="Mutate the statement (list if LLVM IR Instructions) &#39;toMatchMutant&#39; a clone of the original statement..." alt="" coords="1019,1887,1200,1929"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#a7c5ba570719bff722458529619d7bf2f" title=" " alt="" coords="1022,1953,1197,1980"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#aebaab78e010d4e4234107ddcad4f258b" title="Iterators methods." alt="" coords="1034,1247,1185,1289"/>
<area shape="rect" href="structmart_1_1DoReplaceUseful.html#a512dffb28b1bc1e1e115ca62e2b5da65" title=" " alt="" coords="1023,1313,1196,1354"/>
<area shape="rect" href="structmart_1_1DoReplaceUseful.html#ab26112e25e4d7358dd4c28672fa716e8" title=" " alt="" coords="1023,1378,1196,1419"/>
<area shape="rect" href="structmart_1_1DoReplaceUseful.html#a125d32737f9b924f9c467e62a8b67a43" title=" " alt="" coords="1023,1443,1196,1485"/>
<area shape="rect" href="structmart_1_1DoReplaceUseful.html#a2cae13c8373e1790f4ad1079e29266fd" title=" " alt="" coords="1008,1509,1211,1550"/>
<area shape="rect" href="structmart_1_1DoReplaceUseful.html#af4b27c60c9fb0f261fd1b3b62c14a8d7" title=" " alt="" coords="1023,1574,1196,1615"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#ac1bccf83c36543d2c69017355abf4c52" title="Match the IR pattern that can be mutated by this operator, starting from the IR at position &#39;pos&#39;...." alt="" coords="1019,1639,1200,1681"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#af8135f0dbc2bb74bbbea8ebce554af3e" title=" " alt="" coords="1019,1705,1199,1732"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#a9005a341500e44a05a66c17ea6368522" title="make the clones that will be mutated" alt="" coords="1019,1757,1200,1798"/>
<area shape="rect" href="classmart_1_1UserMaps.html#a9b4a853971cf3b5f2afa47a9c04d70a4" title=" " alt="" coords="988,1059,1231,1085"/>
<area shape="rect" href="structmart_1_1ModuleUserInfos.html#aa4b29d09d13a650213d2aeba903bd89f" title=" " alt="" coords="1024,467,1195,509"/>
<area shape="rect" href="structmart_1_1WholeStmtMutationOnce.html#a46c0458e6681449da370e16be2a2cddb" title=" " alt="" coords="703,226,927,267"/>
<area shape="rect" href="structmart_1_1WholeStmtMutationOnce.html#a6b2cd0bbfbadf03f51eb6919daac95a5" title=" " alt="" coords="703,291,927,333"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html#a689ca298ae6ee072ee17af66a4ba295d" title="get the matcher/replacor code for the operation that can delete any statement (like return,..." alt="" coords="709,43,920,85"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a9be7a8b80187e6cd20a704352441bf0e" title=" " alt="" coords="480,2291,621,2333"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a7227537ba250ce935c7eecf6e5abf805" title=" " alt="" coords="744,2291,885,2333"/>
</map>
</div>

</div>
</div>
<a id="ae82180586186545d25fa2578a543b6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82180586186545d25fa2578a543b6d5">&#9670;&nbsp;</a></span>matchIRs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mart::FunctionCall::matchIRs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;&#160;</td>
          <td class="paramname"><em>toMatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> const &amp;&#160;</td>
          <td class="paramname"><em>mutationOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1MatchUseful.html">MatchUseful</a> &amp;&#160;</td>
          <td class="paramname"><em>MU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;&#160;</td>
          <td class="paramname"><em>MI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match the IR pattern that can be mutated by this operator, starting from the IR at position 'pos'. For those that create only, report an error. </p>
<p>A pure virtual member. </p><dl class="section return"><dt>Returns</dt><dd>'True' if the pattern is found, else return 'False' </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toMatch</td><td>is the statement in which we want to match the candidate pattern to muatate. </td></tr>
    <tr><td class="paramname">pos</td><td>is the position (starting from 0) of the IR instruction starting point of the match temptative. </td></tr>
    <tr><td class="paramname">MU</td><td>is the structure where the information about the matching are store. It can be used later to prepare cloneIRs (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmart_1_1FunctionCall.html#ac1cf5a1415214cce26f53c8d1e521b7f" title="make the clones that will be mutated">prepareCloneIRs()</a>). It can also be used when the matcher need to match a complex pattern that require using different operations' matchers. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MI</td><td>is the parameter containing the global information. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmart_1_1GenericMuOpBase.html#ac1bccf83c36543d2c69017355abf4c52">mart::GenericMuOpBase</a>.</p>

</div>
</div>
<a id="a7227537ba250ce935c7eecf6e5abf805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7227537ba250ce935c7eecf6e5abf805">&#9670;&nbsp;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mart::FunctionCall::permute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned &gt; const &amp;&#160;</td>
          <td class="paramname"><em>invect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>permutations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1FunctionCall_a7227537ba250ce935c7eecf6e5abf805_icgraph.png" border="0" usemap="#classmart_1_1FunctionCall_a7227537ba250ce935c7eecf6e5abf805_icgraph" alt=""/></div>
<map name="classmart_1_1FunctionCall_a7227537ba250ce935c7eecf6e5abf805_icgraph" id="classmart_1_1FunctionCall_a7227537ba250ce935c7eecf6e5abf805_icgraph">
<area shape="rect" title=" " alt="" coords="617,5,759,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a9be7a8b80187e6cd20a704352441bf0e" title=" " alt="" coords="428,5,569,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#ada24fe68f6dad0638bf5645d0b6d8055" title=" " alt="" coords="201,5,380,47"/>
<area shape="rect" href="classmart_1_1FunctionCall.html#a8f11c184b01072f5061a10ea3e47ebdd" title="Match the IR pattern and mutate. This is entry&#45;point method called during mutation...." alt="" coords="5,5,153,47"/>
</map>
</div>

</div>
</div>
<a id="ac1cf5a1415214cce26f53c8d1e521b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cf5a1415214cce26f53c8d1e521b7f">&#9670;&nbsp;</a></span>prepareCloneIRs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mart::FunctionCall::prepareCloneIRs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;&#160;</td>
          <td class="paramname"><em>toMatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1MatchUseful.html">MatchUseful</a> const &amp;&#160;</td>
          <td class="paramname"><em>MU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;&#160;</td>
          <td class="paramname"><em>repl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1DoReplaceUseful.html">DoReplaceUseful</a> &amp;&#160;</td>
          <td class="paramname"><em>DRU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;&#160;</td>
          <td class="paramname"><em>MI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make the clones that will be mutated </p>
<p>A pure virtual member. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toMatch</td><td>is the statement in which we want to match the candidate pattern to muatate. </td></tr>
    <tr><td class="paramname">pos</td><td>is the position (starting from 0) of the IR instruction starting point of the match temptative. </td></tr>
    <tr><td class="paramname">MU</td><td>is the structure where the information about the matching were store (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmart_1_1FunctionCall.html#ae82180586186545d25fa2578a543b6d5" title="Match the IR pattern that can be mutated by this operator, starting from the IR at position &#39;pos&#39;....">matchIRs()</a>). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DRU</td><td>is the structure containing the information that will be needed to call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmart_1_1GenericMuOpBase.html#a52d8870056fff4d2649b6149ac0837ce" title="Mutate the statement (list if LLVM IR Instructions) &#39;toMatchMutant&#39; a clone of the original statement...">doReplacement()</a>. The information can also be useful for complex matches. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MI</td><td>is the parameter containing the global information. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmart_1_1GenericMuOpBase.html#a9005a341500e44a05a66c17ea6368522">mart::GenericMuOpBase</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/workspace/my_tools/MART/src/lib/operatorsClasses/MatchOnly_Base/SpecialCases/<a class="el" href="FunctionCall_8h_source.html">FunctionCall.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
