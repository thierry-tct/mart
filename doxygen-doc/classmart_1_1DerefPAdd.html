<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MART: A Mutant Generation Tool for LLVM: mart::DerefPAdd Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MART: A Mutant Generation Tool for LLVM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemart.html">mart</a></li><li class="navelem"><a class="el" href="classmart_1_1DerefPAdd.html">DerefPAdd</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classmart_1_1DerefPAdd-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mart::DerefPAdd Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="DerefPAdd_8h_source.html">DerefPAdd.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mart::DerefPAdd:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1DerefPAdd__inherit__graph.png" border="0" usemap="#mart_1_1DerefPAdd_inherit__map" alt="Inheritance graph"/></div>
<map name="mart_1_1DerefPAdd_inherit__map" id="mart_1_1DerefPAdd_inherit__map">
<area shape="rect" title=" " alt="" coords="47,155,177,181"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html" title=" " alt="" coords="5,80,219,107"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html" title=" " alt="" coords="21,5,203,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mart::DerefPAdd:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1DerefPAdd__coll__graph.png" border="0" usemap="#mart_1_1DerefPAdd_coll__map" alt="Collaboration graph"/></div>
<map name="mart_1_1DerefPAdd_coll__map" id="mart_1_1DerefPAdd_coll__map">
<area shape="rect" title=" " alt="" coords="47,155,177,181"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html" title=" " alt="" coords="5,80,219,107"/>
<area shape="rect" href="classmart_1_1GenericMuOpBase.html" title=" " alt="" coords="21,5,203,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab329986903bd5551d04a80743ace1fe8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPAdd.html#ab329986903bd5551d04a80743ace1fe8">matchIRs</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> const &amp;mutationOp, unsigned pos, <a class="el" href="structmart_1_1MatchUseful.html">MatchUseful</a> &amp;MU, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:ab329986903bd5551d04a80743ace1fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match the IR pattern that can be mutated by this operator, starting from the IR at position 'pos'. For those that create only, report an error.  <a href="classmart_1_1DerefPAdd.html#ab329986903bd5551d04a80743ace1fe8">More...</a><br /></td></tr>
<tr class="separator:ab329986903bd5551d04a80743ace1fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad072efb1da89b74c7cddce605372aa14"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPAdd.html#ad072efb1da89b74c7cddce605372aa14">createReplacement</a> (llvm::Value *oprd1_addrOprd, llvm::Value *oprd2_intValOprd, std::vector&lt; llvm::Value * &gt; &amp;replacement, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:ad072efb1da89b74c7cddce605372aa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">create and operation using the passed operands. For thos that match only, report an error.  <a href="classmart_1_1DerefPAdd.html#ad072efb1da89b74c7cddce605372aa14">More...</a><br /></td></tr>
<tr class="separator:ad072efb1da89b74c7cddce605372aa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmart_1_1DerefPointerArith__Base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmart_1_1DerefPointerArith__Base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmart_1_1DerefPointerArith__Base.html">mart::DerefPointerArith_Base</a></td></tr>
<tr class="memitem:a1d7274823d72eab9ed3574bd0eaba274 inherit pub_methods_classmart_1_1DerefPointerArith__Base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPointerArith__Base.html#a1d7274823d72eab9ed3574bd0eaba274">prepareCloneIRs</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, unsigned pos, <a class="el" href="structmart_1_1MatchUseful.html">MatchUseful</a> const &amp;MU, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1DoReplaceUseful.html">DoReplaceUseful</a> &amp;DRU, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:a1d7274823d72eab9ed3574bd0eaba274 inherit pub_methods_classmart_1_1DerefPointerArith__Base"><td class="mdescLeft">&#160;</td><td class="mdescRight">make the clones that will be mutated  <a href="classmart_1_1DerefPointerArith__Base.html#a1d7274823d72eab9ed3574bd0eaba274">More...</a><br /></td></tr>
<tr class="separator:a1d7274823d72eab9ed3574bd0eaba274 inherit pub_methods_classmart_1_1DerefPointerArith__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmart_1_1GenericMuOpBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmart_1_1GenericMuOpBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmart_1_1GenericMuOpBase.html">mart::GenericMuOpBase</a></td></tr>
<tr class="memitem:ae3fdf68be2f9bf6770e0b1547b16e74e inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#ae3fdf68be2f9bf6770e0b1547b16e74e">~GenericMuOpBase</a> ()</td></tr>
<tr class="separator:ae3fdf68be2f9bf6770e0b1547b16e74e inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a5f21c843085d4be1e0180dec105e8 inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a97a5f21c843085d4be1e0180dec105e8">matchAndReplace</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> const &amp;mutationOp, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;iswholestmtmutated, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:a97a5f21c843085d4be1e0180dec105e8 inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match the IR pattern and mutate. This is entry-point method called during mutation. Reimplement this as needed. \detail The method take a statement, a code pattern type to match (Ex: Add 2 integers) as well as the muatant code pattern and generatemutated clones of the statement.  <a href="classmart_1_1GenericMuOpBase.html#a97a5f21c843085d4be1e0180dec105e8">More...</a><br /></td></tr>
<tr class="separator:a97a5f21c843085d4be1e0180dec105e8 inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95545ab2f94944d4f0da0c8c26faa53f inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a95545ab2f94944d4f0da0c8c26faa53f">getMinIRInstructionsToBeMatched</a> ()</td></tr>
<tr class="memdesc:a95545ab2f94944d4f0da0c8c26faa53f inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thismethod is useful to help filter before hand the operation that can never be matched in a stmt. overload this in the operator classes.  <a href="classmart_1_1GenericMuOpBase.html#a95545ab2f94944d4f0da0c8c26faa53f">More...</a><br /></td></tr>
<tr class="separator:a95545ab2f94944d4f0da0c8c26faa53f inherit pub_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9561143ea9a44cfad24e27d366f1f527"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPAdd.html#a9561143ea9a44cfad24e27d366f1f527">getCorrespondingAritPtrOp</a> ()</td></tr>
<tr class="memdesc:a9561143ea9a44cfad24e27d366f1f527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements from <a class="el" href="classmart_1_1DerefPointerArith__Base.html">DerefPointerArith_Base</a>.  <a href="classmart_1_1DerefPAdd.html#a9561143ea9a44cfad24e27d366f1f527">More...</a><br /></td></tr>
<tr class="separator:a9561143ea9a44cfad24e27d366f1f527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f80479af2c80bec47e790bd60e1b73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPAdd.html#ae2f80479af2c80bec47e790bd60e1b73">dereferenceFirst</a> ()</td></tr>
<tr class="memdesc:ae2f80479af2c80bec47e790bd60e1b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements from <a class="el" href="classmart_1_1DerefPointerArith__Base.html">DerefPointerArith_Base</a>.  <a href="classmart_1_1DerefPAdd.html#ae2f80479af2c80bec47e790bd60e1b73">More...</a><br /></td></tr>
<tr class="separator:ae2f80479af2c80bec47e790bd60e1b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fb841797834375a213aa5dbbf45fd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPAdd.html#a14fb841797834375a213aa5dbbf45fd0">isCommutative</a> ()</td></tr>
<tr class="separator:a14fb841797834375a213aa5dbbf45fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmart_1_1DerefPointerArith__Base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmart_1_1DerefPointerArith__Base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmart_1_1DerefPointerArith__Base.html">mart::DerefPointerArith_Base</a></td></tr>
<tr class="memitem:aeeac35edba68633f5082fc972aec9f5d inherit pro_methods_classmart_1_1DerefPointerArith__Base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPointerArith__Base.html#aeeac35edba68633f5082fc972aec9f5d">checkPtrContainedType</a> (llvm::Value *pval)</td></tr>
<tr class="separator:aeeac35edba68633f5082fc972aec9f5d inherit pro_methods_classmart_1_1DerefPointerArith__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e612a7a846b9eb86710d13c1f56b9d inherit pro_methods_classmart_1_1DerefPointerArith__Base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPointerArith__Base.html#a07e612a7a846b9eb86710d13c1f56b9d">getSubMatchMutationOp</a> (<a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> const &amp;mutationOp, <a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> &amp;tmpMutationOp)</td></tr>
<tr class="separator:a07e612a7a846b9eb86710d13c1f56b9d inherit pro_methods_classmart_1_1DerefPointerArith__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf4c84ed9c9ee5f543a577e65eb0ee0 inherit pro_methods_classmart_1_1DerefPointerArith__Base"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1DerefPointerArith__Base.html#a8cf4c84ed9c9ee5f543a577e65eb0ee0">getSingleUsePos</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, unsigned pos, unsigned &amp;ret_pos)</td></tr>
<tr class="separator:a8cf4c84ed9c9ee5f543a577e65eb0ee0 inherit pro_methods_classmart_1_1DerefPointerArith__Base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmart_1_1GenericMuOpBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmart_1_1GenericMuOpBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmart_1_1GenericMuOpBase.html">mart::GenericMuOpBase</a></td></tr>
<tr class="memitem:aca35f9420c452f9c5e51821d52097f1e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#aca35f9420c452f9c5e51821d52097f1e">isSequentialType</a> (const llvm::Type *type)</td></tr>
<tr class="memdesc:aca35f9420c452f9c5e51821d52097f1e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tels whether the llvm type is a sequential type.  <a href="classmart_1_1GenericMuOpBase.html#aca35f9420c452f9c5e51821d52097f1e">More...</a><br /></td></tr>
<tr class="separator:aca35f9420c452f9c5e51821d52097f1e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eba5272a8370c83f75bf4a603d38b83 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a8eba5272a8370c83f75bf4a603d38b83">isCompositeType</a> (const llvm::Type *type)</td></tr>
<tr class="memdesc:a8eba5272a8370c83f75bf4a603d38b83 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tels whether the llvm type is a composite type.  <a href="classmart_1_1GenericMuOpBase.html#a8eba5272a8370c83f75bf4a603d38b83">More...</a><br /></td></tr>
<tr class="separator:a8eba5272a8370c83f75bf4a603d38b83 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5291dbb8115dd6bd6efc55e3b86b11a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#ac5291dbb8115dd6bd6efc55e3b86b11a">checkCPTypeInIR</a> (enum <a class="el" href="namespacemart.html#aff3b79ebfdbde74c201459822668f148">codeParts</a> cpt, llvm::Value *val)</td></tr>
<tr class="memdesc:ac5291dbb8115dd6bd6efc55e3b86b11a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">the method checkCPTypeInIR - "Check Code Part Type In IR" - validate the seen value type match with the expected one. \detail Use this when matching IR with code parts to mutate, to match each oprd in IR with expected CPType  <a href="classmart_1_1GenericMuOpBase.html#ac5291dbb8115dd6bd6efc55e3b86b11a">More...</a><br /></td></tr>
<tr class="separator:ac5291dbb8115dd6bd6efc55e3b86b11a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe944b290c20a4bbdd13255f59dbcc8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">llvm::Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a0fe944b290c20a4bbdd13255f59dbcc8">createIfConst</a> (llvm::Type *type, unsigned posConstValueMap_POS)</td></tr>
<tr class="memdesc:a0fe944b290c20a4bbdd13255f59dbcc8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method obtain a constant numeric from a string contained in a static structure of.  <a href="classmart_1_1GenericMuOpBase.html#a0fe944b290c20a4bbdd13255f59dbcc8">More...</a><br /></td></tr>
<tr class="separator:a0fe944b290c20a4bbdd13255f59dbcc8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8294e52f9debc2dfddc4038145250f71 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a8294e52f9debc2dfddc4038145250f71">reverseCast</a> (llvm::Instruction::CastOps toRev, llvm::Value *subj, llvm::Type *destTy)</td></tr>
<tr class="memdesc:a8294e52f9debc2dfddc4038145250f71 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method applies the reverse of a "cast" instruction. Ex: passing IntToPtr will return PtrToInt.  <a href="classmart_1_1GenericMuOpBase.html#a8294e52f9debc2dfddc4038145250f71">More...</a><br /></td></tr>
<tr class="separator:a8294e52f9debc2dfddc4038145250f71 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae833ae34954dc85511ccd6acd9a65c4e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#ae833ae34954dc85511ccd6acd9a65c4e">getTerminatorDeleterCode</a> ()</td></tr>
<tr class="memdesc:ae833ae34954dc85511ccd6acd9a65c4e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the matcher/replacor code for the operation that can delete statement which are block terminators (like return, break, continue)  <a href="classmart_1_1GenericMuOpBase.html#ae833ae34954dc85511ccd6acd9a65c4e">More...</a><br /></td></tr>
<tr class="separator:ae833ae34954dc85511ccd6acd9a65c4e inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bea55a64c6aa3bea0f26ab0bb0f32c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a21bea55a64c6aa3bea0f26ab0bb0f32c">getGenericDeleterCode</a> ()</td></tr>
<tr class="memdesc:a21bea55a64c6aa3bea0f26ab0bb0f32c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the matcher/replacor code for the operation that can delete any statement (like return, break, continue)  <a href="classmart_1_1GenericMuOpBase.html#a21bea55a64c6aa3bea0f26ab0bb0f32c">More...</a><br /></td></tr>
<tr class="separator:a21bea55a64c6aa3bea0f26ab0bb0f32c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689ca298ae6ee072ee17af66a4ba295d inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a689ca298ae6ee072ee17af66a4ba295d">getGenericTrapInserterCode</a> ()</td></tr>
<tr class="memdesc:a689ca298ae6ee072ee17af66a4ba295d inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the matcher/replacor code for the operation that can delete any statement (like return, break, continue)  <a href="classmart_1_1GenericMuOpBase.html#a689ca298ae6ee072ee17af66a4ba295d">More...</a><br /></td></tr>
<tr class="separator:a689ca298ae6ee072ee17af66a4ba295d inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd889ccd23a76605410fcab652a6fc9 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#affd889ccd23a76605410fcab652a6fc9">isDeletion</a> (enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a> m)</td></tr>
<tr class="memdesc:affd889ccd23a76605410fcab652a6fc9 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an operation is Del stmt, which deletes the whole statement, or for return statement, set returned value to 0.  <a href="classmart_1_1GenericMuOpBase.html#affd889ccd23a76605410fcab652a6fc9">More...</a><br /></td></tr>
<tr class="separator:affd889ccd23a76605410fcab652a6fc9 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c9cb3f51681b060417d0819e881d7c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#aa0c9cb3f51681b060417d0819e881d7c">isTrapInsertion</a> (enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a> m)</td></tr>
<tr class="memdesc:aa0c9cb3f51681b060417d0819e881d7c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an operation is Trap stmt, which replace the whole statement by trap(basically inserting trap before) This make the program abort when the stmt is reached.  <a href="classmart_1_1GenericMuOpBase.html#aa0c9cb3f51681b060417d0819e881d7c">More...</a><br /></td></tr>
<tr class="separator:aa0c9cb3f51681b060417d0819e881d7c inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc34edc65cee39c46f286f994d2326d1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#afc34edc65cee39c46f286f994d2326d1">doDeleteStmt</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;iswholestmtmutated, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:afc34edc65cee39c46f286f994d2326d1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the mutant of delete stmt, for the case where the statement is not a terminator (break, continue, return). For that,.  <a href="classmart_1_1GenericMuOpBase.html#afc34edc65cee39c46f286f994d2326d1">More...</a><br /></td></tr>
<tr class="separator:afc34edc65cee39c46f286f994d2326d1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f28b422ddada01b8a9c2deaa7982e1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#ae5f28b422ddada01b8a9c2deaa7982e1">doTrapStmt</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;iswholestmtmutated, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:ae5f28b422ddada01b8a9c2deaa7982e1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the mutant of trap stmt, for the case where the statement.  <a href="classmart_1_1GenericMuOpBase.html#ae5f28b422ddada01b8a9c2deaa7982e1">More...</a><br /></td></tr>
<tr class="separator:ae5f28b422ddada01b8a9c2deaa7982e1 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af011cf018d29f485e1d4af0b60e9edf8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#af011cf018d29f485e1d4af0b60e9edf8">checkWholeStmtAndMutate</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1WholeStmtMutationOnce.html">WholeStmtMutationOnce</a> &amp;iswholestmtmutated, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI)</td></tr>
<tr class="memdesc:af011cf018d29f485e1d4af0b60e9edf8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the replacer is wholestmt mutation and return true or false. if it is, create the corresponding mutation  <a href="classmart_1_1GenericMuOpBase.html#af011cf018d29f485e1d4af0b60e9edf8">More...</a><br /></td></tr>
<tr class="separator:af011cf018d29f485e1d4af0b60e9edf8 inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5999df8142a41800b6f240f4e0e3822a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a5999df8142a41800b6f240f4e0e3822a">constAndEquals</a> (llvm::Value *c1, llvm::Value *c2)</td></tr>
<tr class="memdesc:a5999df8142a41800b6f240f4e0e3822a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two values of the same type are constant and of same values.  <a href="classmart_1_1GenericMuOpBase.html#a5999df8142a41800b6f240f4e0e3822a">More...</a><br /></td></tr>
<tr class="separator:a5999df8142a41800b6f240f4e0e3822a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb27fe2351ba131fdb30509b00f3556a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#afb27fe2351ba131fdb30509b00f3556a">checkIsPointerIndexingAndGet</a> (llvm::GetElementPtrInst const *gep, int &amp;index)</td></tr>
<tr class="separator:afb27fe2351ba131fdb30509b00f3556a inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d8870056fff4d2649b6149ac0837ce inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmart_1_1GenericMuOpBase.html#a52d8870056fff4d2649b6149ac0837ce">doReplacement</a> (<a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;toMatch, <a class="el" href="structmart_1_1MutantsOfStmt.html">MutantsOfStmt</a> &amp;resultMuts, <a class="el" href="structmart_1_1llvmMutationOp_1_1MutantReplacors.html">llvmMutationOp::MutantReplacors</a> const &amp;repl, <a class="el" href="structmart_1_1MutantsOfStmt_1_1MutantStmtIR.html">MutantsOfStmt::MutantStmtIR</a> &amp;toMatchMutant, std::vector&lt; unsigned &gt; &amp;posOfIRtoRemove, llvm::Value *oprd1_addrOprd, llvm::Value *oprd2_intValOprd, int returningIRPos, std::vector&lt; unsigned &gt; const &amp;relevantPosInToMatch, <a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;MI, int returnIntoIRPos=-1, int retIntoOprdIndex=-1)</td></tr>
<tr class="memdesc:a52d8870056fff4d2649b6149ac0837ce inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutate the statement (list if LLVM IR Instructions) 'toMatchMutant' a clone of the original statement 'toMatch' then append the mutated statement (from 'toMatchMutant') into 'resultMuts' \detail There are two modes: (1) specifying the IR whose value is replaced by the created operation's value (here all its uses become the uses of the created operation). Such IR is specified with the parameter 'returningIR'. in this case, 'returnIntoIR' must be null and retIntoOprdIndex &lt; 0. (2) Specifying the single IR where the value of the created operation is used ('returnIntoIR'). Here the corresponding operand index is also specified ('retIntoOprdIndex'). Note that 'returningIR' must be null in this case.  <a href="classmart_1_1GenericMuOpBase.html#a52d8870056fff4d2649b6149ac0837ce">More...</a><br /></td></tr>
<tr class="separator:a52d8870056fff4d2649b6149ac0837ce inherit pro_methods_classmart_1_1GenericMuOpBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad072efb1da89b74c7cddce605372aa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad072efb1da89b74c7cddce605372aa14">&#9670;&nbsp;</a></span>createReplacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* mart::DerefPAdd::createReplacement </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>oprd1_addrOprd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>oprd2_intValOprd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;&#160;</td>
          <td class="paramname"><em>MI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create and operation using the passed operands. For thos that match only, report an error. </p>
<p>A pure virtual member </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lh_addrOprdptr</td><td>is the high level left hand operand for non-pointer operation, and pointer (address) operand for operation on pointers. </td></tr>
    <tr><td class="paramname">rh_addrOprdptr</td><td>is the high level right hand operand for non-pointer operation, and non-pointer (non-address) operand for operation on pointer. </td></tr>
    <tr><td class="paramname">replacement</td><td>is the list of IRs representing the created operation </td></tr>
    <tr><td class="paramname">MI</td><td>is the parameter containing the global information. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmart_1_1GenericMuOpBase.html#a2a9dda703a3342a8ac5e6f7330105c1c">mart::GenericMuOpBase</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1DerefPAdd_ad072efb1da89b74c7cddce605372aa14_cgraph.png" border="0" usemap="#classmart_1_1DerefPAdd_ad072efb1da89b74c7cddce605372aa14_cgraph" alt=""/></div>
<map name="classmart_1_1DerefPAdd_ad072efb1da89b74c7cddce605372aa14_cgraph" id="classmart_1_1DerefPAdd_ad072efb1da89b74c7cddce605372aa14_cgraph">
<area shape="rect" title="create and operation using the passed operands. For thos that match only, report an error." alt="" coords="5,143,269,170"/>
<area shape="rect" href="structmart_1_1ModuleUserInfos.html#aa4b29d09d13a650213d2aeba903bd89f" title=" " alt="" coords="358,5,529,47"/>
<area shape="rect" href="classmart_1_1DerefPAdd.html#a9561143ea9a44cfad24e27d366f1f527" title="Implements from DerefPointerArith_Base." alt="" coords="317,71,569,112"/>
<area shape="rect" href="structmart_1_1ModuleUserInfos.html#ae1e5f7d0c42e47cb4eea1c38b2a3417b" title=" " alt="" coords="358,136,529,177"/>
<area shape="rect" href="classmart_1_1UserMaps.html#ad9347edff14677018d4383b95de40c1f" title=" " alt="" coords="339,201,547,243"/>
<area shape="rect" href="structmart_1_1ModuleUserInfos.html#a23b1e979cc8b3d0811c15c6c4bcf1ad0" title=" " alt="" coords="358,267,529,308"/>
</map>
</div>

</div>
</div>
<a id="ae2f80479af2c80bec47e790bd60e1b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f80479af2c80bec47e790bd60e1b73">&#9670;&nbsp;</a></span>dereferenceFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mart::DerefPAdd::dereferenceFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements from <a class="el" href="classmart_1_1DerefPointerArith__Base.html">DerefPointerArith_Base</a>. </p>

<p>Implements <a class="el" href="classmart_1_1DerefPointerArith__Base.html#ab53106e2aaee7f2309b4aa984ba4c0a8">mart::DerefPointerArith_Base</a>.</p>

</div>
</div>
<a id="a9561143ea9a44cfad24e27d366f1f527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9561143ea9a44cfad24e27d366f1f527">&#9670;&nbsp;</a></span>getCorrespondingAritPtrOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemart.html#af5c4ca28f330606a47099b8a5f3efe36">ExpElemKeys</a> mart::DerefPAdd::getCorrespondingAritPtrOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements from <a class="el" href="classmart_1_1DerefPointerArith__Base.html">DerefPointerArith_Base</a>. </p>

<p>Implements <a class="el" href="classmart_1_1DerefPointerArith__Base.html#ad10f5a80d3a1e0f8d4a50d9dfc69eeaa">mart::DerefPointerArith_Base</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1DerefPAdd_a9561143ea9a44cfad24e27d366f1f527_icgraph.png" border="0" usemap="#classmart_1_1DerefPAdd_a9561143ea9a44cfad24e27d366f1f527_icgraph" alt=""/></div>
<map name="classmart_1_1DerefPAdd_a9561143ea9a44cfad24e27d366f1f527_icgraph" id="classmart_1_1DerefPAdd_a9561143ea9a44cfad24e27d366f1f527_icgraph">
<area shape="rect" title="Implements from DerefPointerArith_Base." alt="" coords="317,5,569,47"/>
<area shape="rect" href="classmart_1_1DerefPAdd.html#ad072efb1da89b74c7cddce605372aa14" title="create and operation using the passed operands. For thos that match only, report an error." alt="" coords="5,13,269,39"/>
</map>
</div>

</div>
</div>
<a id="a14fb841797834375a213aa5dbbf45fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14fb841797834375a213aa5dbbf45fd0">&#9670;&nbsp;</a></span>isCommutative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mart::DerefPAdd::isCommutative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classmart_1_1DerefPointerArith__Base.html#a3432700d8ad527e559bb3549ea8e71be">mart::DerefPointerArith_Base</a>.</p>

</div>
</div>
<a id="ab329986903bd5551d04a80743ace1fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab329986903bd5551d04a80743ace1fe8">&#9670;&nbsp;</a></span>matchIRs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mart::DerefPAdd::matchIRs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmart_1_1MatchStmtIR.html">MatchStmtIR</a> const &amp;&#160;</td>
          <td class="paramname"><em>toMatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmart_1_1llvmMutationOp.html">llvmMutationOp</a> const &amp;&#160;</td>
          <td class="paramname"><em>mutationOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1MatchUseful.html">MatchUseful</a> &amp;&#160;</td>
          <td class="paramname"><em>MU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmart_1_1ModuleUserInfos.html">ModuleUserInfos</a> const &amp;&#160;</td>
          <td class="paramname"><em>MI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Match the IR pattern that can be mutated by this operator, starting from the IR at position 'pos'. For those that create only, report an error. </p>
<p>A pure virtual member. </p><dl class="section return"><dt>Returns</dt><dd>'True' if the pattern is found, else return 'False' </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toMatch</td><td>is the statement in which we want to match the candidate pattern to muatate. </td></tr>
    <tr><td class="paramname">pos</td><td>is the position (starting from 0) of the IR instruction starting point of the match temptative. </td></tr>
    <tr><td class="paramname">MU</td><td>is the structure where the information about the matching are store. It can be used later to prepare cloneIRs (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmart_1_1DerefPointerArith__Base.html#a1d7274823d72eab9ed3574bd0eaba274" title="make the clones that will be mutated">prepareCloneIRs()</a>). It can also be used when the matcher need to match a complex pattern that require using different operations' matchers. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MI</td><td>is the parameter containing the global information. </td></tr>
  </table>
  </dd>
</dl>
<p>TODO: As for now we do not cosider the cases where a pointer to an Array is the address operand and GEP directly return the address of an element in the pointed array. EX: i32* = gep [5 x i32]* p, 0, idx. That would be like: gep (gep p, 0, 0), idx So here 'HLOperandSourceIndexInIR(1) == 2' means that the second HLOprd (integer part) index in gep is qual to 1 (2 = 1 + 1) Gep index 1 is llvm::User index 2</p>

<p>Reimplemented from <a class="el" href="classmart_1_1DerefPointerArith__Base.html#af4584d3ed95e0d62f13baf22de2dbaa6">mart::DerefPointerArith_Base</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmart_1_1DerefPAdd_ab329986903bd5551d04a80743ace1fe8_cgraph.png" border="0" usemap="#classmart_1_1DerefPAdd_ab329986903bd5551d04a80743ace1fe8_cgraph" alt=""/></div>
<map name="classmart_1_1DerefPAdd_ab329986903bd5551d04a80743ace1fe8_cgraph" id="classmart_1_1DerefPAdd_ab329986903bd5551d04a80743ace1fe8_cgraph">
<area shape="rect" title="Match the IR pattern that can be mutated by this operator, starting from the IR at position &#39;pos&#39;...." alt="" coords="5,380,204,406"/>
<area shape="rect" href="structmart_1_1MatchStmtIR.html#a263fc935384902366027e19276310275" title=" " alt="" coords="798,102,951,143"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html#af4584d3ed95e0d62f13baf22de2dbaa6" title="Match the IR pattern that can be mutated by this operator, starting from the IR at position &#39;pos&#39;...." alt="" coords="252,759,427,800"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#ac910dd0291487bc5932f8df586719010" title=" " alt="" coords="508,226,672,267"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html#aeeac35edba68633f5082fc972aec9f5d" title=" " alt="" coords="479,291,701,332"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#aabcbf1e1bdd8098c0cf36c9977cd318c" title=" " alt="" coords="1243,430,1393,471"/>
<area shape="rect" href="structmart_1_1MatchStmtIR.html#a3bbcea69562f77ca3810fefe6859a99e" title="Finds the position of an IR instruction in a list of IRs through sequential search from a starting po..." alt="" coords="798,254,951,295"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html#ab53106e2aaee7f2309b4aa984ba4c0a8" title="Say wheter the operation dereference first (ex: (*p)–, *(p)+9, ...)" alt="" coords="503,524,677,566"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#a7c5ba570719bff722458529619d7bf2f" title=" " alt="" coords="503,590,677,617"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#aebaab78e010d4e4234107ddcad4f258b" title="Iterators methods." alt="" coords="515,642,665,683"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html#ad10f5a80d3a1e0f8d4a50d9dfc69eeaa" title="This method is to be implemented by each deref&#45;arith matching&#45;mutating operator." alt="" coords="753,694,996,735"/>
<area shape="rect" href="classmart_1_1llvmMutationOp.html#a3a47b833af5071cbd5fb37fc1ee0212d" title=" " alt="" coords="507,824,673,866"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#a7db3c33b9a1e67ca2b76aa09129f8213" title=" " alt="" coords="511,890,669,931"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#ae4e49cb220d5e39594e3bba4105601db" title=" " alt="" coords="480,955,700,996"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#a9eceff13f8a6dae6a2564616d8ed8abe" title=" " alt="" coords="499,1020,681,1062"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#ae3558fc13161a13441217e507e1ec772" title=" " alt="" coords="511,1086,669,1127"/>
<area shape="rect" href="classmart_1_1UserMaps.html#ad9347edff14677018d4383b95de40c1f" title=" " alt="" coords="486,1151,694,1192"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#ab3b51677c8dc436e8272db1ac271fc6b" title=" " alt="" coords="515,459,665,500"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#ab552c34c27af9d2219206375f347e8f8" title=" " alt="" coords="495,1216,685,1258"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#a988eb4abec778de1cf6173e5bae48f3a" title=" " alt="" coords="515,1282,665,1323"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#a25f8d57905d1cbaa27e51ff61a1445bc" title=" " alt="" coords="514,1347,666,1388"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html#a8cf4c84ed9c9ee5f543a577e65eb0ee0" title=" " alt="" coords="501,160,679,202"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html#a07e612a7a846b9eb86710d13c1f56b9d" title=" " alt="" coords="475,759,705,800"/>
<area shape="rect" href="structmart_1_1ModuleUserInfos.html#a23b1e979cc8b3d0811c15c6c4bcf1ad0" title=" " alt="" coords="505,1412,675,1454"/>
<area shape="rect" href="classmart_1_1DerefPointerArith__Base.html#a3432700d8ad527e559bb3549ea8e71be" title=" " alt="" coords="503,1478,677,1519"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#af8135f0dbc2bb74bbbea8ebce554af3e" title=" " alt="" coords="500,1544,680,1570"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#a2759f7a6029cb2326ac48bd7d3786096" title=" " alt="" coords="509,1595,671,1636"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#af087f89efac1eaea52626f6fde25b664" title=" " alt="" coords="511,43,669,84"/>
<area shape="rect" href="structmart_1_1MutantsOfStmt_1_1MutantStmtIR.html#a1397eb93298fd0ea7024467654a7bacc" title=" " alt="" coords="787,890,963,931"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#a9e2393ff854e636c85fa8d1bd5d29fd3" title="expand" alt="" coords="799,459,950,500"/>
<area shape="rect" href="structmart_1_1MatchUseful.html#aee984755a1fb78fbd7ff3229977de5ad" title=" " alt="" coords="1044,459,1195,500"/>
<area shape="rect" href="classmart_1_1llvmMutationOp.html#a6c95189719478c9eca1ede458d07d900" title=" " alt="" coords="791,759,958,800"/>
<area shape="rect" href="classmart_1_1llvmMutationOp.html#a16786c92761e6a5b7dc3119c5aa4095e" title=" " alt="" coords="791,824,958,866"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/workspace/my_tools/MART/src/lib/operatorsClasses/DerefPointerArith_Base/operators/<a class="el" href="DerefPAdd_8h_source.html">DerefPAdd.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
